// define what is required to build the desktop release (swing)
def desktopProjects() {
    [project('core'), project('cli'), project('swing')]
}

// common settings for desktop (swing) projects
configure(desktopProjects()) {
    apply plugin: 'java'
    sourceCompatibility = 1.7
    targetCompatibility = 1.7
    compileJava.options.encoding = "UTF-8"
}

configure([project('swing')]) {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
}

configure([project('cli')]) {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
}

// configure paths
def signPath = "B:\\\\"
def pRoot = project(":").rootDir.getAbsolutePath()
def buildPath = pRoot + "/tmp/lxcbuild"
def jnaPath = pRoot + "/lib/swing/jna-4.2.1-win-stripped.jar"



///////////////////////////////////
//
// main tasks
//
///////////////////////////////////

// Build IDE jar version
task releaseIDE() {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    description "IDE build for swing version"
    dependsOn "cleanBuildEnv"
    dependsOn desktopProjects().build
    dependsOn "prepareJar"
    dependsOn "prepareJar2"
    dependsOn "prepareJar3"
    dependsOn "desktopJar"
}

// Builds the desktop (swing) release
task releaseDesktop() {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    description "Builds the desktop release with the swing gui."
    dependsOn "cleanBuildEnv"
    dependsOn desktopProjects().build
    dependsOn "prepareJar"
    dependsOn "prepareJar2"
    dependsOn "prepareJar3"
    dependsOn "desktopJar"
    dependsOn "packDesktop"
    doLast {
        copy {
            from (buildPath + "/lxc.zip")
            into (pRoot + "/releases/stable")
        }
        println "Done. Results in releases/stable. Unpack anywhere to install."
    }
}

// Builds the desktop release and packs all files for the automatic update
task packUpdate(dependsOn: desktopProjects().build) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    description "Builds the desktop release and packs it as automatic update."
    
    // Check versions, signing environment
    dependsOn "prepareUpdate"
    
    // interactive setup & checks complete, normal build
    dependsOn "packSignedFiles"
    
    // order
    desktopProjects().build.each {
        it.mustRunAfter ":prepareUpdate"
    }
    
    doLast {
        // copy update master file
        copy {
            from signPath + "/update_master.zip"
            into pRoot + "/update"
        }
        // done!
        println("Done. Commit and push directory \"update\" to apply (do not forget aws!)")
    }
}

///////////////////////////////////
//
// internal tasks
//
///////////////////////////////////

task cleanBuildEnv() {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    doLast {
        deleteRecursive(buildPath)
    }
}

task prepareJar(type: Copy) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn desktopProjects().build
    dependsOn "cleanBuildEnv"
    mustRunAfter desktopProjects().build
    mustRunAfter "cleanBuildEnv"

    def jna_file = file(jnaPath)

    from zipTree(jna_file)
    into buildPath + "/jar"
    exclude "META-INF/*"
}

task prepareJar2(type: Copy) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "prepareJar"
    mustRunAfter "prepareJar"

    from pRoot + "/lib/swing/lxcwin64.dll"
    into buildPath + "/jar/win32-x86-64"
    rename("lxcwin64.dll", "lxcwin.dll")
}

task prepareJar3(type: Copy) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "prepareJar2"
    mustRunAfter "prepareJar2"

    from pRoot + "/lib/swing/lxcwin32.dll"
    into buildPath + "/jar/win32-x86"
    rename("lxcwin32.dll", "lxcwin.dll")
}

// create main jar
task desktopJar(type: Zip) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "prepareJar3"
    mustRunAfter "prepareJar3"

    archiveName "lanxchange.jar"
    destinationDir file(buildPath)

    from buildPath + "/jar"
    from pRoot + "/Ubuntu-R.ttf"
    from pRoot + "/lxc_updates.pub"
    from desktopProjects().sourceSets.main.output
}


// pack desktop release
task packDesktop(type: Zip) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "desktopJar"
    mustRunAfter "desktopJar"
    
    archiveName "lxc.zip"
    destinationDir file(buildPath)
    
    from (pRoot)
    include ("img/*.png")
    include ("COPYING")
    include ("3rd_party_licenses/font_license.txt")
    include ("lxc")
    include ("lxc.exe")
    
    from (buildPath) {
        include("lanxchange.jar")
    }
}

task prepareZip(type: Copy) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "desktopJar"
    mustRunAfter "desktopJar"

    from pRoot + "/lxc.exe"
    into (buildPath + "/tmp_update")
}

// pack desktop release for update
// includes more files, like the update helper and version number file required for updates
task packUpdateZip(type: Zip) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "prepareZip"
    mustRunAfter "prepareZip"

    archiveName "lxc.zip"
    destinationDir file(buildPath)

    from (pRoot)
    include ("img/*.png")
    include ("COPYING")
    include ("3rd_party_licenses/font_license.txt")
    include ("lxc")

    from (pRoot + "/modules/winupdatehelper/target/release") {
        include("update_helper.exe")
    }

    from (buildPath) {
        include("lanxchange.jar")
        include("tmp_update/lxc.exe")
    }

    from (pRoot + "/update/v")
    include ("v")
}

// sign update
task signUpdate(type: JavaExec) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "packUpdateZip"
    mustRunAfter "packUpdateZip"
    
    doFirst {
        // prepare signing environment
        deleteIfExists(signPath + "/lxc.zip")
        deleteIfExists(signPath + "/update_master.zip")
        deleteIfExists(signPath + "/lxc.sign")
        
        // copy update into signing environment
        copy {
            from (buildPath + "/lxc.zip")
            into (signPath)
        }
    }
    
    // sign
    main = "de.tobifleig.lxc.Signer"
    workingDir = signPath
}

// zip signed update
task packSignedFiles(type: Zip) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "signUpdate"
    mustRunAfter "signUpdate"
    
    archiveName "update_master.zip"
    destinationDir file(signPath)
    
    from (signPath) {
        include "lxc.zip"
        include "lxc.sign"
    }
}

// querys for version info and checks signing environment
task prepareUpdate() {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    doLast {
        // Cannot pack without signing environment!
        def signDir = new File(signPath)
        if (!signDir.isDirectory()) {
            throw new InvalidUserDataException("Missing signing environment (" + signPath + ")")
        }

        // read update system metadata
        def mainClassFile = new File(pRoot + "/modules/core/src/main/java/de/tobifleig/lxc/LXC.java")
        ext.newversion = -1
        ext.newversionstring = ""
        mainClassFile.eachLine { line ->
            def matcher = line =~ "\\s*public static final int versionId = ([0-9]+);"
            if (matcher) {
                ext.newversion = matcher.group(1)
            }
            def matcher2 = line =~ "\\s*public static final String versionString = \"([0-9a-zA-Z_\\- .]+)\";"
            if (matcher2) {
                ext.newversionstring = matcher2.group(1)
            }
        }
        if (ext.newversion == -1) {
            throw new InvalidUserDataException("Cannot read version number from modules/core/src/main/java/de/tobifleig/lxc/LXC.java")
        }
        if (ext.newversionstring == "") {
            throw new InvalidUserDataException("Cannot read version name from modules/core/src/main/java/de/tobifleig/lxc/LXC.java")
        }
        def oldversion = -1
        def oldversionstring = ""
        new File(pRoot + "/update/v").withReader { oldversion = it.readLine(); oldversionstring = it.readLine() }
        if (oldversionstring == null || oldversion == -1 || oldversionstring.isEmpty()) {
            throw new InvalidUserDataException("Cannot read old version information from update/v")
        }

        // check if version number was incremented
        if (ext.newversion <= oldversion) {
            throw new InvalidUserDataException("Version number (" + ext.newversion + ") must be greater than the current version (" + oldversion + ")!")
        }

        // check if version text changed
        if (ext.newversionstring == oldversionstring) {
            throw new InvalidUserDataException("Version meta (" + ext.newversionstring + ") must be different from current version (" + oldversionstring + ")!")
        }

        // autogenerate full version text
        ext.newversionstring = "LXC " + ext.newversionstring

        // write new version file
        new File(pRoot + "/update/v").withWriter { out ->
            out.println(ext.newversion)
            out.println(ext.newversionstring)
        }
    }
}

///////////////////////////////////
//
// helpers
//
///////////////////////////////////

void deleteIfExists(String path) {
    def file = new File(path)
    if (file.exists()) {
        file.delete()
    }
}

void deleteRecursive(String path) {
    def file = file(path)
    if (file.isDirectory()) {
        file.list().each{ f ->
            deleteRecursive(path + "/" + f)
        }
    }
    assert !file.exists() || file.delete()
}
