import java.security.KeyPairGenerator

// define what is required to build the desktop release (swing)
def desktopProjects() {
    [project('core'), project('cli'), project('swing')]
}

// common settings for desktop (swing) projects
configure(desktopProjects()) {
    apply plugin: 'java'
    sourceCompatibility = 1.7
    targetCompatibility = 1.7
    compileJava.options.encoding = "UTF-8"
}

configure([project('swing')]) {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
}

configure([project('cli')]) {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
}

// not part of desktopProjects to prevent circular dep
configure([project('packaging')]) {
    apply plugin: 'java'
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
    compileJava.options.encoding = "UTF-8"
}

// configure paths
def pRoot = project(":").rootDir.getAbsolutePath()
def buildPath = pRoot + "/tmp/lxcbuild"
def jnaPath = pRoot + "/lib/swing/jna-4.2.1-win-stripped.jar"

def builds = [
        "Prod": [
                "signPath" : "B:\\\\",
                "extraSignPrep" : "Nothing",
        ],
        "Test": [
                "signPath": "modules/packaging/res/env",
                "extraSignPrep": "PrepTestSignEnv"
        ],
]

///////////////////////////////////
//
// main tasks
//
///////////////////////////////////

// Build IDE jar version
task releaseIDE() {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    description "IDE build for swing version"
    dependsOn "cleanBuildEnv"
    dependsOn desktopProjects().build
    dependsOn "prepareJar"
    dependsOn "prepareJar2"
    dependsOn "prepareJar3"
    dependsOn "desktopJar"
}

// Builds the desktop (swing) release
task releaseDesktop() {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    description "Builds the desktop release with the swing gui."
    dependsOn "cleanBuildEnv"
    dependsOn desktopProjects().build
    dependsOn "prepareJar"
    dependsOn "prepareJar2"
    dependsOn "prepareJar3"
    dependsOn "desktopJar"
    dependsOn "packDesktop"
    doLast {
        copy {
            from (buildPath + "/lxc.zip")
            into (pRoot + "/releases/stable")
        }
        println "Done. Results in releases/stable. Unpack anywhere to install."
    }
}

// Builds the desktop release and packs all files for the automatic update
builds.each {name, props ->
    tasks.register("packUpdate$name") {
        // trick gradle into always running this :/
        inputs.file("COPYING")
        outputs.upToDateWhen { false }

        description "Builds the desktop release and packs it as automatic update."

        // Check versions, signing environment
        dependsOn "prepareUpdate$name"
        mustRunAfter "prepareUpdate$name"

        // interactive setup & checks complete, normal build
        dependsOn "packSignedFiles$name"
        mustRunAfter "packSignedFiles$name"


        doLast {
            // copy update master file
            copy {
                from "$props.signPath" + "/update_master.zip"
                into pRoot + "/update"
            }
            // done!
            println("Done. Commit and push directory \"update\" to apply (do not forget aws!)")
        }
    }
}

///////////////////////////////////
//
// internal tasks
//
///////////////////////////////////

task cleanBuildEnv() {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    doLast {
        deleteRecursive(buildPath)
    }
}

task PrepTestSignEnv() {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn project('core').build

    doLast {
        def testSignPath = builds.Test.signPath
        deleteRecursive(testSignPath)
        new File(testSignPath + "/de/tobifleig/lxc/util").mkdirs()

        copy {
            from(project('core').sourceSets.main.output.classesDirs.getSingleFile().getAbsolutePath() + "/de/tobifleig/lxc/util/Signer.class")
            into(testSignPath + "/de/tobifleig/lxc/util/")
        }

        // create keys for test
        def gen = KeyPairGenerator.getInstance("RSA")
        gen.initialize(1024)
        def keyPair = gen.genKeyPair()
        def priv = keyPair.getPrivate().getEncoded()
        def pub = keyPair.getPublic().getEncoded()
        new File(testSignPath + "/lxc_updates.priv").withOutputStream {
            it.write priv
        }
        new File(testSignPath + "/lxc_updates.pub").withOutputStream {
            it.write pub
        }
    }
}

task Nothing() {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    doLast {
        // aaaaah gradle
    }
}


task prepareJar(type: Copy) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn desktopProjects().build
    dependsOn "cleanBuildEnv"
    mustRunAfter desktopProjects().build
    mustRunAfter "cleanBuildEnv"

    def jna_file = file(jnaPath)

    from zipTree(jna_file)
    into buildPath + "/jar"
    exclude "META-INF/*"
}

task prepareJar2(type: Copy) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "prepareJar"
    mustRunAfter "prepareJar"

    from pRoot + "/lib/swing/lxcwin64.dll"
    into buildPath + "/jar/win32-x86-64"
    rename("lxcwin64.dll", "lxcwin.dll")
}

task prepareJar3(type: Copy) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "prepareJar2"
    mustRunAfter "prepareJar2"

    from pRoot + "/lib/swing/lxcwin32.dll"
    into buildPath + "/jar/win32-x86"
    rename("lxcwin32.dll", "lxcwin.dll")
}

// create main jar
task desktopJar(type: Zip) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "prepareJar3"
    mustRunAfter "prepareJar3"

    archiveName "lanxchange.jar"
    destinationDir file(buildPath)

    from buildPath + "/jar"
    from pRoot + "/Ubuntu-R.ttf"
    from pRoot + "/lxc_updates.pub"
    from desktopProjects().sourceSets.main.output
}


// pack desktop release
task packDesktop(type: Zip) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "desktopJar"
    mustRunAfter "desktopJar"
    
    archiveName "lxc.zip"
    destinationDir file(buildPath)
    
    from (pRoot)
    include ("img/*.png")
    include ("COPYING")
    include ("3rd_party_licenses/font_license.txt")
    include ("lxc")
    include ("lxc.exe")
    
    from (buildPath) {
        include("lanxchange.jar")
    }
}

task prepareZip(type: Copy) {
    // trick gradle into always running this :/
    inputs.file("COPYING")
    outputs.upToDateWhen { false }

    dependsOn "desktopJar"
    mustRunAfter "desktopJar"

    from pRoot + "/lxc.exe"
    into (buildPath + "/tmp_update")
}

// pack desktop release for update
// includes more files, like the update helper and version number file required for updates
builds.each { name, props ->
    tasks.register("packUpdateZip$name", Zip) {
        // trick gradle into always running this :/
        inputs.file("COPYING")
        outputs.upToDateWhen { false }

        dependsOn "prepareZip"
        mustRunAfter "prepareZip"

        mustRunAfter "prepareUpdate$name"

        archiveName "lxc.zip"
        destinationDir file(buildPath)

        from(pRoot)
        include("img/*.png")
        include("COPYING")
        include("3rd_party_licenses/font_license.txt")
        include("lxc")

        from(pRoot + "/modules/winupdatehelper/target/release") {
            include("update_helper.exe")
        }

        from(buildPath) {
            include("lanxchange.jar")
            include("tmp_update/lxc.exe")
        }

        from(pRoot + "/update/v")
        include("v")
    }
}

// sign update
builds.each { name, props ->
    tasks.register("signUpdate$name", JavaExec) {
        // trick gradle into always running this :/
        inputs.file("COPYING")
        outputs.upToDateWhen { false }

        dependsOn "packUpdateZip$name"
        mustRunAfter "packUpdateZip$name"

        doFirst {
            def signPath = "$props.signPath"
            // prepare signing environment
            deleteIfExists(signPath + "/lxc.zip")
            deleteIfExists(signPath + "/update_master.zip")
            deleteIfExists(signPath + "/lxc.sign")

            // copy update into signing environment
            copy {
                from(buildPath + "/lxc.zip")
                into(signPath)
            }
        }

        // sign
        main = "de.tobifleig.lxc.util.Signer"
        workingDir = "$props.signPath"
    }
}

// zip signed update
builds.each { name, props ->
    tasks.register("packSignedFiles$name", Zip) {
        // trick gradle into always running this :/
        inputs.file("COPYING")
        outputs.upToDateWhen { false }

        dependsOn "signUpdate$name"
        mustRunAfter "signUpdate$name"

        archiveName "update_master.zip"
        destinationDir file("$props.signPath")

        from("$props.signPath") {
            include "lxc.zip"
            include "lxc.sign"
        }
    }
}

// querys for version info and checks signing environment
builds.each { name, props ->
    tasks.register("prepareUpdate$name") {
        // trick gradle into always running this :/
        inputs.file("COPYING")
        outputs.upToDateWhen { false }

        dependsOn "$props.extraSignPrep".split(",")
        mustRunAfter "$props.extraSignPrep".split(",")

        doLast {
            def signPath = "$props.signPath"
            // Cannot pack without signing environment!
            def signDir = new File(signPath)
            if (!signDir.isDirectory()) {
                throw new InvalidUserDataException("Missing signing environment (" + signPath + ")")
            }

            // read update system metadata
            def mainClassFile = new File(pRoot + "/modules/core/src/main/java/de/tobifleig/lxc/LXC.java")
            ext.newversion = -1
            ext.newversionstring = ""
            mainClassFile.eachLine { line ->
                def matcher = line =~ "\\s*public static final int versionId = ([0-9]+);"
                if (matcher) {
                    ext.newversion = matcher.group(1)
                }
                def matcher2 = line =~ "\\s*public static final String versionString = \"([0-9a-zA-Z_\\- .]+)\";"
                if (matcher2) {
                    ext.newversionstring = matcher2.group(1)
                }
            }
            if (ext.newversion == -1) {
                throw new InvalidUserDataException("Cannot read version number from modules/core/src/main/java/de/tobifleig/lxc/LXC.java")
            }
            if (ext.newversionstring == "") {
                throw new InvalidUserDataException("Cannot read version name from modules/core/src/main/java/de/tobifleig/lxc/LXC.java")
            }
            def oldversion = -1
            def oldversionstring = ""
            new File(pRoot + "/update/v").withReader { oldversion = it.readLine(); oldversionstring = it.readLine() }
            if (oldversionstring == null || oldversion == -1 || oldversionstring.isEmpty()) {
                throw new InvalidUserDataException("Cannot read old version information from update/v")
            }

            // check if version number was incremented
            if (ext.newversion <= oldversion) {
                throw new InvalidUserDataException("Version number (" + ext.newversion + ") must be greater than the current version (" + oldversion + ")!")
            }

            // check if version text changed
            if (ext.newversionstring == oldversionstring) {
                throw new InvalidUserDataException("Version meta (" + ext.newversionstring + ") must be different from current version (" + oldversionstring + ")!")
            }

            // autogenerate full version text
            ext.newversionstring = "LXC " + ext.newversionstring

            // write new version file
            new File(pRoot + "/update/v").withWriter { out ->
                out.println(ext.newversion)
                out.println(ext.newversionstring)
            }
        }
    }
}
///////////////////////////////////
//
// helpers
//
///////////////////////////////////

void deleteIfExists(String path) {
    def file = new File(path)
    if (file.exists()) {
        file.delete()
    }
}

void deleteRecursive(String path) {
    def file = file(path)
    if (file.isDirectory()) {
        file.list().each{ f ->
            deleteRecursive(path + "/" + f)
        }
    }
    assert !file.exists() || file.delete()
}
